#+TITLE: Report
#+AUTHOR: Adam Mertzenich, Kritib Bhattarai, Michael Musa
#+EMAIL: mertad01@luther.edu, bhatkr01@luther.edu, musami01@luther.edu
#+OPTIONS: toc:nil

* TODO Application Usage (Need Images)
#+begin_comment
How-to-use-it instructions for your application, ideally with annotated diagrams/pictures (a video demonstration is not acceptable)
#+end_comment


How-to-use-it instructions for your application, ideally with annotated diagrams/pictures (a video demonstration is not acceptable)

In order to use the application you will need to compile the Main.java file. This can be done using the following command in the root project directory =javac edu/luther/cs252/group1/Main.java=. Next you may run it using =java edu.luther.cs252.group1.Main=. Alternatively, you can download the precompiled java jar file from GitHub and run it using =java -jar vm252-project.jar=.

After launching the application you can start using it. First, use the file+open menu and select a valid VM252 object file. In this document we will be using a simple multiplication program. You can verify that the object file has been loaded by seeing that the object file location has been loaded in the menu bar and that the memory table has values in the cells. The current program counter will be rendered as the TK.color.yellow.

Running the program to completion can be done by selecting the "Run" menu near the top right of the screen and then pressing the "Run" button within. You can also add a delay in milliseconds in the input box to the right of the "Run" menu and use the "Run", "Start", and "Pause" buttons to slowly step through the program. Alternatively, you can manually click "Execute Next" on the left hand side of the screen to run one instruction at a time. If you need to reset the program counter and accumulator use the "Z" button in the top right of the window's menu bar. You can also change the program counter and accumulator using the related input boxes on the right side panel by entering a number and pressing enter.

Breakpoints will result in the program being paused if it's running and notify you with a popup, or just a popup if you are manually executing each instruction. You can toggle breakpoints at a memory address by right clicking a cell of the memory table and they will change to be TK.color.color. Alternatively you can add breakpoints by inputting the source-line number relating to an instruction in the "Breakpoint Line #" input box on the top left of the left side panel. Below you will find a "Clear Breakpoints" button to disable all breakpoints.

There are two different views of the memory, the single-byte hex representation and the double-byte hex representation. In the single-byte hex view you see each cell representing a byte of memory, the two-byte hex view displays two bytes in each cell. You can double click a cell and enter a new value to change the memory (0-FF for single-byte, 0-FFFF for double-byte). Both tables will automatically be updated to represent changes in the memory model. You can see the next instruction to be executed in the bottom panel of the screen as well as the currently selected memory address location.

* DONE Minimum Requirements
#+begin_comment
A description of how the minimum requirements for the assignment have been met or not met (i.e., the capabilities of the aa, ap, amb, ba, h, mb, n, ob, q, r, s, and z commands along with the capability of loading an object file for execution have been provided), with particular mention of all the aspects of the r command (see lines 40-52 of the Phase 4 handout)
#+end_comment


Getting help is done by hovering over components and reading the tool-tip or reading the popup boxes supplied with the menu bar's "Help" section (=h=). You can quit the application by just closing the window (=q=).

We have met all of the minimally required commands. Altering the accumulator and program counter for the =aa= and =ap= commands can be done using the input boxes on the right side ProgramStatePanel. This also covers the displaying of the program counter and accumulator which is part of the =s= command, the rest of the =s= command is fulfilled with the "Next Instruction" label on the bottom of the screen (instruction tracing =t= is also completed simultaneously).

The contents of the machine's memory and the portions containing object code are displayed in our MemoryTable in the center (=ob= and =mb=). Altering the memory is done by editing the cells of the table with a new unsigned hex value (=amb=).

Breakpoints can be added by right clicking on a cell of the table, changing the text color as an indicator (=ba=). Breakpoints will be triggered when running instructions using the "Execute Next" button on the left side button panel or using the "Run" menu items (=n=). When done executing a program you can reinitialize the program counter and accumulator using the "Z" button in the top menu (=z=).

Our "Run" menu and the related delay input box fulfill the =r= command requirements. Without any delay entered you can select "Run" from the menu to execute the entire program. Alternatively, you can set a delay value in milliseconds in the input box and when you run it will slowly step through the program, with the ability to "Pause" and "Start" again. All views are automatically updated.

* DONE Beyond the Minimum
#+begin_comment
Mention of any of any capabilities above the minimum requirements that have been provided (e.g., the capabilities of the bl, mi, and oi commands)
#+end_comment


Our VM252 application fulfills the majority of the "extra" commands, going beyond the minimally required commands. You may use the "Breakpoint Line #" input box on the left side panel to enter a source line number to add a breakpoint and can click the "Clear Breaks" button below it to clear all breakpoints (=bl= and =cb=).

Using the "Double-Byte Hex" tab in the top center of the memory view you can choose to view the machine memory and object code as 2-byte hex data (=od= and =md=). You can edit these cells to new unsigned hex values for the =amdx= command functionality.

* TODO Roles and Contributions

A description of the roles and contributions of each of the members of the group over the lifetime of the project.

* TODO Libraries Used
#+begin_comment
A list of which standard or third-party libraries the application uses, with an explanation of the purpose of third-party libraries
#+end_comment

* DONE Class Relationship Family-Tree Diagram
#+begin_comment
A family-tree diagram of the class relationships of the classes the group defined for its code
#+end_comment

[[./ClassHierarchy.png]]

* TODO Design Patterns
#+begin_comment
A discussion of how and where any design patterns and idioms (especially Model-View-Controller) are reflected in the applicationâ€™s design
#+end_comment

We heavily rely upon both the Observer-Observed and the Model-View-Controller design patterns (hierarchy image at the bottom of this section).

[[./MVC-OBS.png]]

* TODO Original Coding
#+begin_comment
Any other original coding in the application not related to assembling components for and interfacing with the GUI
#+end_comment

* TODO Persistent Information
#+begin_comment
How any persistent information (i.e., information that must survive across multiple executions of your application), if any, is handled by your application
#+end_comment


* TODO Other Features
#+begin_comment
Any other special design or implementation features of the final application the group feels should be pointed out
#+end_comment
